Ejercicio 1) 

function hayBolitas_EnCeldaAl_(colorDeLasBolitas, direccion){
    /*
    Propósito:
    - Indica si hay bolitas del color **colorDeLasBolitas** en la celda lindante a la celda actual hacia la dirección **direccion**.
    Parámetros:
    - colorDeLasBolitas: Color / Color de las bolitas a indicar.
    - direccion: Dirección / Dirección hacia dónde mover el cabezal.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    Mover(direccion)
    return(choose True when (hayBolitas(colorDeLasBolitas))
                  False otherwise)
}

Ejercicio 2) 

function hayBolitas_Al_(colorDeLasBolitas, direccion){
    /*
    Propósito:
    - Indica si hay una celda lindante a la celda actual hacia la dirección **direccion** que contenga al menos una bolita de color **colorDeLasBolitas**. Si no hay celda lindante, describe False.
    Parámetros:
    - colorDeLasBolitas: Color / Color de las bolitas a buscar.
    - direccion: Dirección / Dirección hacia la cual buscar.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (choose True when (puedeMover(direccion) && hayBolitas_EnCeldaAl_(colorDeLasBolitas, direccion))
                   False otherwise)
}

Ejercicio 3) 

function hayBolitas_EnElBorde_(color, direccion){
    /*
    Propósito:
    - Indica si hay bolitas del color **color** en la celda correspondiente al borde hacia la dirección **direccion**.
    Parámetros: 
    color: Color / Color de las bolitas a indicar.
    direccion: Dirección / Dirección a indicar si hay bolitas del color **color** en el borde.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    IrAlBorde(direccion)
    return (hayBolitas(color))
}

Ejercicio 4) 

function hayBolitas_Hacia_(color, direccion){
    /*
    Propósito:
    - Indica si en alguna celda hacia la dirección **direccion** hay una bolita del color **color**. 
    Parámetros:
    - color: Color / Color de las bolitas a buscar.
    - direccion: Dirección / Dirección hacia dónde buscar las bolitas del color **color**. 
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre las celdas de la fila hacia la dirección **direccion**, buscando una celda que contenga al menos una bolita de color **color**.
    */
    Mover(direccion)
    while (not hayBolitas(color) && puedeMover(direccion)){
        Mover(direccion)
    }
    return (hayBolitas(color))
}

Ejercicio 5) 

function hayCeldaVacíaHacia_(direccion){
    /*
    Propósito:
    - Indicar si alguna de las celdas hacia la dirección **direccion** desde la celda actual está vacía. 
    Parámetros:
    - direccion: Dirección / Dirección hacia dónde buscar.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre las celdas de la fila hacia la dirección **direccion**. Buscando una celda que se encuentre vacía.
    */
    Mover(direccion)
    while (not esCeldaVacia() && puedeMover(direccion)){
        Mover(direccion)
    }
    return (esCeldaVacia())
}

function esCeldaVacia(){
    /*
    Propósito: Indica si la celda actual está vacía.
    Precondición:
    - Ninguna
    Tipo: Booleano
    */
    return (not hayBolitas(Rojo) && not hayBolitas(Verde) && not hayBolitas(Azul) && not hayBolitas(Negro))
}

Ejercicio 6) 

function hayAlgunaBolita_(color){
    /*
    Propósito:
    - Indica si hay alguna celda que contenga al menos una bolita del color **color** en el tablero.
    Parámetros:
    - color: Color / Color de la bolita a buscar.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre las celdas del tablero, buscando una celda que contenga al menos una bolita de color **color**.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && not hayBolitas(color)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    return (hayBolitas(color))
}

Ejercicio 7)

function hayAlgunaCeldaVacia(){
    /*
    Propósito:
    - Indica si hay alguna celda vacía en el tablero.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre las celdas del tablero, buscando una celda vacía.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && not esCeldaVacia()){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    return (esCeldaVacia())
}

Ejercicio 8) 

procedure CopiarCeldaAl_(direccion){
    /*
    Propósito:
    - Copiar el contenido de la celda actual a la celda lindante a la dirección **direccion**.
    Parámetros:
    - direccion: Dirección / Dirección hacia dónde copiar la celda actual.
    Precondiciones:
    - Debe haber una celda lindante desde la celda actual hacia la dirección **direccion**.
    */
    bolitasAzules := nroBolitas(Azul)
    bolitasVerdes := nroBolitas(Verde)
    bolitasNegras := nroBolitas(Negro)
    bolitasRojas  := nroBolitas(Rojo)
    Mover(direccion)
    VaciarCelda()
    Poner_DeColor_(bolitasAzules, Azul)
    Poner_DeColor_(bolitasVerdes, Verde)
    Poner_DeColor_(bolitasNegras, Negro)
    Poner_DeColor_(bolitasRojas, Rojo)
}

procedure Mover_VecesAl_ (cantidadAMover, direccionAMover){
    /*
    Propósito: Dado un número "cantidadAMover" y una dirección "direccionAMover", mover el cabezal tantas veces como el número dado hacia la direccón dada.
    Parámetros:
    - cantidadAMover: número / cantidad de celdas a mover el cabezal.
    - direccionAMover: dirección / dirección hacia dónde mover el cabezal.
    Precondiciones: Debe haber al menos tantas celdas como se indique en "cantidadAMover" hacia "direccionAMover"
    */   
    repeat (cantidadAMover){
        Mover(direccionAMover)
    }
}

procedure SacarTodasLasDeColor_ (colorASacar){
    /*
    Propósito: Sacar todas las bolitas del color **colorASacar** de la celda actual. 
    Parámetros:
    - colorASacar: Color / color de las bolitas a sacar.
    Precondiciones:
    Ninguna.
    */
    repeat(nroBolitas(colorASacar)){
        Sacar(colorASacar)
    }
}

procedure Poner_DeColor_(cantidadAPoner, colorAPoner){
    /*
    Propósito: Dado un número "cantidadAPoner" y un color "colorAPoner", poner tantas bolitas de un determinado color en la celda actual.
    Parámetros:
    - cantidadAPoner: número / cantidad de bolitas rojas a poner.
    - colorAPoner: color / color de las bolitas a poner.
    Precondiciones: Ninguna.
    */
    repeat (cantidadAPoner){
        Poner(colorAPoner)
    }
}

procedure VaciarCelda(){
    /*
    Propósito: 
    - Eliminar todas las bolitas de colores de la celda actual.
    Precondiciones:
    - Ninguna.
    */
    SacarTodasLasDeColor_(Rojo)
    SacarTodasLasDeColor_(Verde)
    SacarTodasLasDeColor_(Negro)
    SacarTodasLasDeColor_(Azul)
}

Ejercicio 9)

procedure CopiarOrigenEnEsquinas(){
    /*
    Propósito: 
    - Copiar en cada esquina del tablero los contenidos de la celda actual. El cabezal no necesita finalizar en la celda inicial.
    Precondiciones: 
    - Ninguna. 
    Observaciones: 
    - Las 4 esquinas deben terminar con exactamente las mismas bolitas de cada color que había en la celda inicial.
    */
    bolitasAzules := nroBolitas(Azul)
    bolitasRojas := nroBolitas(Rojo)
    bolitasVerdes := nroBolitas(Verde)
    bolitasNegras := nroBolitas(Negro)
    IrAEsquinaAl_Y_(Norte, Oeste)
    VaciarCelda()
    Poner_DeColor_ (bolitasAzules, Azul)
    Poner_DeColor_ (bolitasRojas, Rojo)
    Poner_DeColor_ (bolitasVerdes, Verde)
    Poner_DeColor_ (bolitasNegras, Negro)
    IrAEsquinaAl_Y_(Sur, Oeste)
    VaciarCelda()
    Poner_DeColor_ (bolitasAzules, Azul)
    Poner_DeColor_ (bolitasRojas, Rojo)
    Poner_DeColor_ (bolitasVerdes, Verde)
    Poner_DeColor_ (bolitasNegras, Negro)
    IrAEsquinaAl_Y_(Norte, Este)
    VaciarCelda()
    Poner_DeColor_ (bolitasAzules, Azul)
    Poner_DeColor_ (bolitasRojas, Rojo)
    Poner_DeColor_ (bolitasVerdes, Verde)
    Poner_DeColor_ (bolitasNegras, Negro)
    IrAEsquinaAl_Y_(Sur, Este)
    VaciarCelda()
    Poner_DeColor_ (bolitasAzules, Azul)
    Poner_DeColor_ (bolitasRojas, Rojo)
    Poner_DeColor_ (bolitasVerdes, Verde)
    Poner_DeColor_ (bolitasNegras, Negro)
}

procedure SacarTodasLasDeColor_ (colorASacar){
    /*
    Propósito: Sacar todas las bolitas del color **colorASacar** de la celda actual. 
    Parámetros:
    - colorASacar: Color / color de las bolitas a sacar.
    Precondiciones:
    Ninguna.
    */
    repeat(nroBolitas(colorASacar)){
        Sacar(colorASacar)
    }
}

procedure Poner_DeColor_(cantidadAPoner, colorAPoner){
    /*
    Propósito: Dado un número "cantidadAPoner" y un color "colorAPoner", poner tantas bolitas de un determinado color en la celda actual.
    Parámetros:
    - cantidadAPoner: número / cantidad de bolitas rojas a poner.
    - colorAPoner: color / color de las bolitas a poner.
    Precondiciones: Ninguna.
    */
    repeat (cantidadAPoner){
        Poner(colorAPoner)
    }
}

procedure VaciarCelda(){
    /*
    Propósito: 
    - Eliminar todas las bolitas de colores de la celda actual.
    Precondiciones:
    - Ninguna.
    */
    SacarTodasLasDeColor_(Rojo)
    SacarTodasLasDeColor_(Verde)
    SacarTodasLasDeColor_(Negro)
    SacarTodasLasDeColor_(Azul)
}

procedure IrAEsquinaAl_Y_ (primeraDireccion, segundaDireccion){
    /*
    Propósito: Dadas dos direcciones, mover el cabezal hacia la esquina entre dichas direcciones.
    Parámetros:
    - primeraDireccion: dirección / Primera dirección hacia la cual mover el cabezal.
    - segundaDireccion: dirección / Segunda dirección hacia la cual mover el cabezal.
    Precondiciones:  Ninguna.
    */    
    IrAlBorde(primeraDireccion)
    IrAlBorde(segundaDireccion)
}

Ejercicio 12) 

function minimoEntre_Y_(primerValor, segundoValor){
    /*
    Propósito: 
    - Indica cual de los dos valores "primerValor" y "segundoValor" es más chico.
    Parámetros: 
    - primerValor: Cualquiera / Primer valor a comparar.
    - segundoValor: Cualquiera / Segundo valor a comparar.
    Tipo: Número
    */ 
    return (choose (primerValor) when (primerValor <= segundoValor)
    segundoValor otherwise)
}

Ejercicio 13) 

function minimoEntre_Y_(primerValor, segundoValor){
    /*
    Propósito: 
    - Indica cual de los dos valores "primerValor" y "segundoValor" es más chico.
    Parámetros: 
    - primerValor: Cualquiera / Primer valor a comparar.
    - segundoValor: Cualquiera / Segundo valor a comparar.
    Tipo: Número
    */ 
    return (choose (primerValor) when (primerValor >= segundoValor)
    segundoValor otherwise)
}

Ejercicio 15) 

function jugadaGanadoraDePiedraPapelOTijerasEntre_Y_ (primeraJugada, segundaJugada){
    /*
    Propósito: 
    - Indicar la jugada ganadora entre **primeraJugada** y **segundaJugada**.
    Parámetros: 
    - primeraJugada: cualquiera / Indica el primer valor.
    - segundaJugada: cualquiera / Indica el segundo valor.
    Tipo: Devuelve el mismo tipo que **primeraJugada** y **segundaJugada**.
    Precondiciones: 
    - **primeraJugada** y **segundaJugada** deben ser del mismo tipo. 
    - **primeraJugada** y **segundaJugada** no pueden ser iguales.
    */
    return (choose primeraJugada when (primeraJugada == piedra() && segundaJugada == tijeras())
                   primeraJugada when (primeraJugada == papel() && segundaJugada == piedra())
                   primeraJugada when (primeraJugada == tijeras() && segundaJugada == papel())
                   segundaJugada when (segundaJugada == piedra() && primeraJugada == tijeras())
                   segundaJugada when (segundaJugada == papel() && primeraJugada == piedra())
                   segundaJugada otherwise)
}

Ejercicio 16) 

function jugadaGanadoraDePiedraPapelOTijerasLagartoSpockEntre_Y_ (primeraJugada, segundaJugada){
    /*
    Propósito: 
    - Indicar la jugada ganadora entre **primeraJugada** y **segundaJugada**.
    Parámetros: 
    - primeraJugada: cualquiera / Indica el primer valor.
    - segundaJugada: cualquiera / Indica el segundo valor.
    Tipo: Devuelve el mismo tipo que **primeraJugada** y **segundaJugada**.
    Precondiciones: 
    - **primeraJugada** y **segundaJugada** deben ser del mismo tipo. 
    - **primeraJugada** y **segundaJugada** no pueden ser iguales.
    */
    return (choose primeraJugada when (primeraJugada == piedra() && (segundaJugada == tijeras() || segundaJugada                == lagarto()))
                   primeraJugada when (primeraJugada == papel() && (segundaJugada == piedra() || segundaJugada == spock()))
                   primeraJugada when (primeraJugada == tijeras() && (segundaJugada == papel() || segundaJugada == lagarto()))
                   primeraJugada when (primeraJugada == lagarto() && (segundaJugada == spock() || segundaJugada == papel()))
                   primeraJugada when (primeraJugada== spock() && (segundaJugada == tijeras || segundaJugada == piedra()))
                   segundaJugada when (segundaJugada == piedra() && (primeraJugada == tijeras() || primeraJugada == lagarto()))
                   segundaJugada when (segundaJugada == papel() && (primeraJugada == piedra() || primeraJugada== spock()))
                   segundaJugada when (segundaJugada == tijeras() && (primeraJugada == papel() || primeraJugada == lagarto()))
                   segundaJugada when (segundaJugada == lagarto() && (primeraJugada == spock() || primeraJugada == papel()))
                   segundaJugada otherwise)
}

Ejercicio 17) 

function nroBolitas_EnLaFilaActual(color){
    /*
    Propósito: 
    - Indicar la cantidad de bolitas del color **color** en la fila actual.
    - El cabezal no necesita finalizar en la celda inicial.
    Parámetros:
    - color: Color / Color de las bolitas a contar.
    Precondiciones: 
    - Ninguna.
    Observaciones: Es un recorrido de acumulación de las celdas de la fila actual. Contando el número de bolitas de color **color**.
    */
    IrAlBorde(Oeste)
    contadorDeBolitas := 0
    while (puedeMover(Este)){
        contadorDeBolitas := contadorDeBolitas + nroBolitas(color)
        Mover(Este)
    }
    contadorDeBolitas := contadorDeBolitas + nroBolitas(color)
    return (contadorDeBolitas)
}

Ejercicio 18) 

function distanciaAlBorde_(bordeAIndicar){
    /*
    Propósito: 
    - Indica la cantidad de celdas que hay entre la celda actual y el borde **bordeAIndicar**
    Parámetro: 
    - bordeAIndicar: Dirección / dirección hacia dónde cuenta el cabezal.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones:
    - Es un recorrdido de acumulación sobre las celdas del tablero. Contando las celdas hacia el borde desde la celda actual. (la celda actual no está incluida)
    */
    contadorDeCeldas := 0 
    while (puedeMover(bordeAIndicar)) {
        Mover(bordeAIndicar)
        contadorDeCeldas := contadorDeCeldas + 1
    }
    return (contadorDeCeldas)
}

Ejercicio 19) 

a) 
function coordenadaX(){
    /*
    Propósito:
    - Indicar la coordenada de la columna de la celda actual.
    Precondiciones: 
    - Ninguna.
    Tipo: Número
    Observaciones: 
    - Es un recorrido de acumulación sobre las celdas del tablero. Contando las celdas desde la celda actual hasta el borde Oeste. (la celda actual está incluida) 
    */
    return (distanciaAlBorde_(Oeste))
}

b) 
function coordenadaY(){
    /*
    Propósito:
    - Indicar la coordenada de la fila de la celda actual.
    Precondiciones: 
    - Ninguna.
    Tipo: Número
    Observaciones: 
    - Es un recorrido de acumulación sobre las celdas del tablero. Contando las celdas desde la celda actual hasta el borde Sur. (la celda actual está incluida) 
    */
    return (distanciaAlBorde_(Sur))
}

Ejercicio 20) 

a) 
function nroFilas(){
    /*
    Propósito:
    - Indicar la cantidad de filas del tablero actual.
    Precondiciones: 
    - Ninguna.
    Tipo: Número
    */
    return (distanciaAlBorde_(Sur) + distanciaAlBorde_(Norte) + 1)
}

function distanciaAlBorde_(bordeAIndicar){
    /*
    Propósito: 
    - Indica la cantidad de celdas que hay entre la celda actual y el borde **bordeAIndicar**
    Parámetro: 
    - bordeAIndicar: Dirección / dirección hacia dónde cuenta el cabezal.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones:
    - Es un recorrdido de acumulación sobre las celdas del tablero. Contando las celdas hacia el borde desde la celda actual. (la celda actual no está incluida)
    */
    contadorDeCeldas := 0 
    while (puedeMover(bordeAIndicar)) {
        Mover(bordeAIndicar)
        contadorDeCeldas := contadorDeCeldas + 1
    }
    return (contadorDeCeldas)
}

b) 
function nroColumnas(){
    /*
    Propósito:
    - Indicar la cantidad de columnas del tablero actual.
    Precondiciones: 
    - Ninguna.
    Tipo: Número
    */
    return (distanciaAlBorde_(Este) + distanciaAlBorde_(Oeste) + 1)
}

function distanciaAlBorde_(bordeAIndicar){
    /*
    Propósito: 
    - Indica la cantidad de celdas que hay entre la celda actual y el borde **bordeAIndicar**
    Parámetro: 
    - bordeAIndicar: Dirección / dirección hacia dónde cuenta el cabezal.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones:
    - Es un recorrdido de acumulación sobre las celdas del tablero. Contando las celdas hacia el borde desde la celda actual. (la celda actual no está incluida)
    */
    contadorDeCeldas := 0 
    while (puedeMover(bordeAIndicar)) {
        Mover(bordeAIndicar)
        contadorDeCeldas := contadorDeCeldas + 1
    }
    return (contadorDeCeldas)
}

Ejercicio 21) 

function nroVacias(){
    /*
    Propósito: 
    - Indicar la cantidad de celdas vacías en el tablero.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones: 
    - Es un recorrido de acumulación, recorriendo las celdas del tablero. Contando las celdas vacías.
    */
    IrAEsquinaAl_Y_(Oeste, Sur)
    nroCeldasVacias := 0
    nroCeldasVacias := nroCeldasVacias + unoSi_CeroSiNo(esCeldaVacia())
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        nroCeldasVacias := nroCeldasVacias + unoSi_CeroSiNo(esCeldaVacia())
    }
    return (nroCeldasVacias)
}


function unoSi_CeroSiNo(valor){
    /*
    Propósito: 
    - Indica si la condición se cumple o no. Si se cumple, indica 1 y sino, indica 0.
    Parámetros:
    - valor: Cualquiera / Valor a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (choose 1 when (valor)
                    0 otherwise)
}

procedure IrAEsquinaAl_Y_ (primeraDireccion, segundaDireccion){
    /*
    Propósito: Dadas dos direcciones, mover el cabezal hacia la esquina entre dichas direcciones.
    Parámetros:
    - primeraDireccion: dirección / Primera dirección hacia la cual mover el cabezal.
    - segundaDireccion: dirección / Segunda dirección hacia la cual mover el cabezal.
    Precondiciones:  Ninguna.
    */    
    IrAlBorde(primeraDireccion)
    IrAlBorde(segundaDireccion)
}

function esCeldaVacia(){
    /*
    Propósito: Indica si la celda actual está vacía.
    Precondición:
    - Ninguna
    Tipo: Booleano
    */
    return (not hayBolitas(Rojo) && not hayBolitas(Verde) && not hayBolitas(Azul) && not hayBolitas(Negro))
}

procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito:
    - Dirigir el cabezal hacia la primera celda en dónde se comenzará el recorrido de las direcciones **dirPrincipal** y **dirSecundaria**
    Parámetros:
    - dirPrincipal: Dirección / Primera dirección hacia dónde irá el recorrido.
    - dirSecundaria: Dirección / Segunda dirección hacia dónde irá el recorrido.
    Precondición:
    - Ninguna.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito: 
    - Indica si hay una siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / primera dirección a tener en cuenta si hay celdas.
    - dirSecundaria: Dirección / segunda dirección a tener en cuenta si hay celdas.
    Precondición:
    - Ninguna.
    Tipo: Booleano.
    */
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito:
    - Dirigir el cabezal a la siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / Primera dirección hacia dónde se moverá en el recorrido.
    - dirSecundaria: Dirección / Segunda dirección hacia dónde se moverá en el recorrido.
    Precondición:
    - **dirPrincipal** y **dirSecundaria** no pueden ser opuestas ni iguales.
    */
    if (puedeMover(dirPrincipal)) then {
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}

Ejercicio 22)

function cantidadDeCeldasConBolitasDeColor_ (color){
    /*
    Propósito: 
    - Indica la cantidad de celdas que contienen al menos una bolita del color **color**.
    Parámetros: 
    - color: Color / Color a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones:
    - Es un recorrido de acumulación, recorriendo las celdas del tablero. Acumula la cantidad de celdas que tienen al menos una bolita del color **color**.
    */
    IrAEsquinaAl_Y_(Oeste, Sur)
    nroCeldasConBolitas := 0
    nroCeldasConBolitas := nroCeldasConBolitas + unoSi_CeroSiNo(hayBolitas(color))
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        nroCeldasConBolitas := nroCeldasConBolitas + unoSi_CeroSiNo(hayBolitas(color))
    }
    return (nroCeldasConBolitas)
}

function unoSi_CeroSiNo(valor){
    /*
    Propósito: 
    - Indica si la condición se cumple o no. Si se cumple, indica 1 y sino, indica 0.
    Parámetros:
    - valor: Cualquiera / Valor a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (choose 1 when (valor)
                    0 otherwise)
}

procedure IrAEsquinaAl_Y_ (primeraDireccion, segundaDireccion){
    /*
    Propósito: Dadas dos direcciones, mover el cabezal hacia la esquina entre dichas direcciones.
    Parámetros:
    - primeraDireccion: dirección / Primera dirección hacia la cual mover el cabezal.
    - segundaDireccion: dirección / Segunda dirección hacia la cual mover el cabezal.
    Precondiciones:  Ninguna.
    */    
    IrAlBorde(primeraDireccion)
    IrAlBorde(segundaDireccion)
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito: 
    - Indica si hay una siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / primera dirección a tener en cuenta si hay celdas.
    - dirSecundaria: Dirección / segunda dirección a tener en cuenta si hay celdas.
    Precondición:
    - Ninguna.
    Tipo: Booleano.
    */
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito:
    - Dirigir el cabezal a la siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / Primera dirección hacia dónde se moverá en el recorrido.
    - dirSecundaria: Dirección / Segunda dirección hacia dónde se moverá en el recorrido.
    Precondición:
    - **dirPrincipal** y **dirSecundaria** no pueden ser opuestas ni iguales.
    */
    if (puedeMover(dirPrincipal)) then {
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}

Ejercicio 23) 

function nroBolitasTotalDeColor_ (color){
    /*
    Propósito: 
    - Indica la cantidad de bolitas totales del color **color** en el tablero.
    Parámetros: 
    - color: Color / Color a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones:
    - Es un recorrido de acumulación, recorriendo las celdas del tablero. Acumula la cantidad de bolitas totales del color **color** que hay en el tablero.
    */
    IrAEsquinaAl_Y_(Oeste, Sur)
    nroTotalBolitas := 0
    nroTotalBolitas := nroTotalBolitas + nroBolitas(color)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)) {
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        nroTotalBolitas := nroTotalBolitas + nroBolitas(color)
    }
    return (nroTotalBolitas)
}

function unoSi_CeroSiNo(valor){
    /*
    Propósito: 
    - Indica si la condición se cumple o no. Si se cumple, indica 1 y sino, indica 0.
    Parámetros:
    - valor: Cualquiera / Valor a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (choose 1 when (valor)
                    0 otherwise)
}

procedure IrAEsquinaAl_Y_ (primeraDireccion, segundaDireccion){
    /*
    Propósito: Dadas dos direcciones, mover el cabezal hacia la esquina entre dichas direcciones.
    Parámetros:
    - primeraDireccion: dirección / Primera dirección hacia la cual mover el cabezal.
    - segundaDireccion: dirección / Segunda dirección hacia la cual mover el cabezal.
    Precondiciones:  Ninguna.
    */    
    IrAlBorde(primeraDireccion)
    IrAlBorde(segundaDireccion)
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito: 
    - Indica si hay una siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / primera dirección a tener en cuenta si hay celdas.
    - dirSecundaria: Dirección / segunda dirección a tener en cuenta si hay celdas.
    Precondición:
    - Ninguna.
    Tipo: Booleano.
    */
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito:
    - Dirigir el cabezal a la siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / Primera dirección hacia dónde se moverá en el recorrido.
    - dirSecundaria: Dirección / Segunda dirección hacia dónde se moverá en el recorrido.
    Precondición:
    - **dirPrincipal** y **dirSecundaria** no pueden ser opuestas ni iguales.
    */
    if (puedeMover(dirPrincipal)) then {
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}

Ejercicio 24) 

function cantidadDeAutosEnLaCarretera(){
    /*
    Propósito: 
    - Indica la cantidad de autos en la carretera.
    Precondiciones: 
    - Ninguna.
    Tipo: Número.
    Observaciones:
    - Es un recorrido de acumulación, recorriendo las celdas del tablero. Acumula la cantidad de autos que hay en la carretera.
    */
    IrAEsquinaAl_Y_(Oeste, Sur)
    nroDeAutos := 0
    nroDeAutos := nroDeAutos + unoSi_CeroSiNo(hayUnAuto())
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)) {
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        nroDeAutos := nroDeAutos + unoSi_CeroSiNo(hayUnAuto())
    }
    return (nroDeAutos)
}

function hayUnAuto(){
/*
PROPÓSITO: Indica si hay un auto en la celda actual.
TIPO: Booleano.
PRECONDICIONES: Ninguna.
*/
    return (hayBolitas(Negro))
}

function unoSi_CeroSiNo(valor){
    /*
    Propósito: 
    - Indica si la condición se cumple o no. Si se cumple, indica 1 y sino, indica 0.
    Parámetros:
    - valor: Cualquiera / Valor a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (choose 1 when (valor)
                    0 otherwise)
}

procedure IrAEsquinaAl_Y_ (primeraDireccion, segundaDireccion){
    /*
    Propósito: Dadas dos direcciones, mover el cabezal hacia la esquina entre dichas direcciones.
    Parámetros:
    - primeraDireccion: dirección / Primera dirección hacia la cual mover el cabezal.
    - segundaDireccion: dirección / Segunda dirección hacia la cual mover el cabezal.
    Precondiciones:  Ninguna.
    */    
    IrAlBorde(primeraDireccion)
    IrAlBorde(segundaDireccion)
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito: 
    - Indica si hay una siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / primera dirección a tener en cuenta si hay celdas.
    - dirSecundaria: Dirección / segunda dirección a tener en cuenta si hay celdas.
    Precondición:
    - Ninguna.
    Tipo: Booleano.
    */
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
    Propósito:
    - Dirigir el cabezal a la siguiente celda en un recorrido hacia las direcciones **dirPrincipal** y **dirSecundaria**.
    Parámetros:
    - dirPrincipal: Dirección / Primera dirección hacia dónde se moverá en el recorrido.
    - dirSecundaria: Dirección / Segunda dirección hacia dónde se moverá en el recorrido.
    Precondición:
    - **dirPrincipal** y **dirSecundaria** no pueden ser opuestas ni iguales.
    */
    if (puedeMover(dirPrincipal)) then {
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}

Ejercicio 26) 

function unoSi_CeroSiNo(valor){
    /*
    Propósito: 
    - Indica si la condición se cumple o no. Si se cumple, indica 1 y sino, indica 0.
    Parámetros:
    - valor: Cualquiera / Valor a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (choose 1 when (valor)
                    0 otherwise)
}

Ejercicio 28)

procedure PonerUnaDeCadaColor(){
    /*
    Propósito: 
    - Poner una bolita de cada color en la celda actual.
    Precondiciones:
    - Ninguna.
    Observaciones: 
    - Es un recorrido de procesamiento sobre la celda actual. 
    */
    colorActual := minColor()
    while (colorActual /= maxColor()){
        Poner(colorActual)
        colorActual := siguiente (colorActual)
    }
    Poner(colorActual)
}

Ejercicio 29) 

procedure LimpiarCruzDeColor_(colorDeLaCruz){
    /*
    Propósito: 
    - Quitar una cruz hecha por las bolitas del color **color**.
    Parámetros: 
    - colorDeLaCruz: Color / Color de la cruz a quitar.
    Precondiciones: 
    - El cabezal debe estár ubicado en el centro de la cruz.
    Observaciones: 
    - Es un recorrido de procesamiento sobre direcciones.
    */
    dirActual := minDir()
    while (dirActual /= maxDir()){
        SacarBolitasDeColor_Hacia_(colorDeLaCruz, dirActual)
        dirActual := siguiente (dirActual) 
    }
    SacarBolitasDeColor_Hacia_(colorDeLaCruz, dirActual)
    Sacar(Rojo)
}

procedure SacarBolitasDeColor_Hacia_(colorASacar, direccion){
    /*
    Propósito: 
    - Sacar las bolitas de color **color** hacia la dirección **direccion**. El cabezal debe finalizar en la celda inicial.
    Parámetros: 
    - colorASacar: Color / color de las bolitas a sacar.
    - direccion: Dirección / dirección hacia dónde sacar las bolitas.
    */
    celdasRecorridas := 0
    while (puedeMover(direccion)) {
        Mover(direccion)
        SacarTodasLasDeColor_(colorASacar)
        celdasRecorridas := celdasRecorridas + 1
    }
    Mover_VecesAl_ (celdasRecorridas, opuesto(direccion))
}

procedure Mover_VecesAl_ (cantidadAMover, direccionAMover){
    /*
    Propósito: Dado un número "cantidadAMover" y una dirección "direccionAMover", mover el cabezal tantas veces como el número dado hacia la direccón dada.
    Parámetros:
    - cantidadAMover: número / cantidad de celdas a mover el cabezal.
    - direccionAMover: dirección / dirección hacia dónde mover el cabezal.
    Precondiciones: Debe haber al menos tantas celdas como se indique en "cantidadAMover" hacia "direccionAMover"
    */   
    repeat (cantidadAMover){
        Mover(direccionAMover)
    }
}

procedure SacarTodasLasDeColor_ (colorASacar){
    /*
    Propósito: Sacar todas las bolitas del color **colorASacar** de la celda actual. 
    Parámetros:
    - colorASacar: Color / color de las bolitas a sacar.
    Precondiciones:
    Ninguna.
    */
    repeat(nroBolitas(colorASacar)){
        Sacar(colorASacar)
    }
}

Ejercicio 30) 

function direcciónHaciaLaCualHayBolitasDe_ (colorAIndicar){
    /*
    Propósito: 
    - Indica la dirección hacia la cual hay bolitas del color **colorAIndicar**.
    Parámetros: 
    - colorAIndicar: Color / color de las bolitas a indicar.
    Precondiciones: 
    - Debe existir una celda vecina que tenga al menos una bolita del color **colorAIndicar**.
    - No hay más de una celda vecina con bolitas del color **colorAIdentificar**.
    Tipo: Dirección.
    Observaciones: 
    - Es un recorrido de busqueda sobre las celdas del tablero. Indicando hacia qué dirección hay una bolita de color **colorAIndicar**.
    */
    dirActual := minDir()
    while (dirActual /= maxDir() && not hayBolitas_Al_(colorAIndicar, dirActual)){
        dirActual := siguiente (dirActual) 
    }
    return (dirActual)
}

function hayBolitas_Al_(color, direccion){
    /*
    Propósito: Indica si existe una celda hacia la dirección **direccion** y si la celda lindante hacia la dirección **dirección** posee bolitas del color **color**. 
    Parámetros: 
    - color: Color / color de las bolitas a ver.
    - direccion: Dirección / dirección hacia dónde mover el cabezal.
    Precondición: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (puedeMover(direccion) && hayBolitas_EnCeldaAl_(color, direccion))
}

function hayBolitas_EnCeldaAl_(color, direccion){
    /*
    */
    Mover(direccion)
    return(hayBolitas(color))
}

Ejercicio 31) 

function cantidadDeVecinasConBolitas(){
    /*
    Propósito: 
    - Indica la cantidad de celdas vecinas con bolitas de cualquier color. 
    Precondiciones: 
    - Ninguna. 
    Tipo: Número.
    Observaciones: 
    - Es un recorrido de acumulación sobre las celdas del tablero. Acumulando la cantidad de celdas que tengan al menos una bolita de cualquier color.
    */
    dirActual := minDir()
    contadorDeCeldas := 0
    while (dirActual /= maxDir()){
        Mover(dirActual)
        contadorDeCeldas := contadorDeCeldas + unoSi_CeroSiNo(esCeldaConBolitas())
        Mover(siguiente(dirActual))
        contadorDeCeldas := contadorDeCeldas + unoSi_CeroSiNo(esCeldaConBolitas())
        Mover(previo(dirActual)) 
        Mover(opuesto(dirActual)) 
        dirActual := siguiente (dirActual) 
    }
        Mover(dirActual)
        contadorDeCeldas := contadorDeCeldas + unoSi_CeroSiNo(esCeldaConBolitas())
        Mover(siguiente(dirActual))
        contadorDeCeldas := contadorDeCeldas + unoSi_CeroSiNo(esCeldaConBolitas())
        Mover(previo(dirActual)) 
        Mover(opuesto(dirActual)) 
    return (contadorDeCeldas)
}

function unoSi_CeroSiNo(valor){
    /*
    Propósito: 
    - Indica si la condición se cumple o no. Si se cumple, indica 1 y sino, indica 0.
    Parámetros:
    - valor: Cualquiera / Valor a evaluar.
    Precondiciones: 
    - Ninguna.
    Tipo: Booleano.
    */
    return (choose 1 when (valor)
                    0 otherwise)
}

function esCeldaConBolitas(){
    /*
    Propósito: Indica si la celda actual hay al menos una bolita de cualquier color.
    Precondición:
    - Ninguna
    Tipo: Booleano
    */
    return (hayBolitas(Rojo) || hayBolitas(Verde) || hayBolitas(Azul) || hayBolitas(Negro))
}

Ejercicio 32) 

procedure Poner_EnLineaHacia_De_IncrementandoDeA_ComenzandoEn_(cantidad, direccion, color, factorDeIncremento, numeroInicial){
    /*
    Propósito: 
    - Pone una línea de bolitas hacia la dirección **direccion** de un largo indicado por el número **cantidad**, del color **colo** y que inicia con el número **numeroInicial** en la primera línea y va incrementando y sumando por cada celda que recorre la cantidad de bolitas de la celda anterior más el número **factorDeIncremento**.
    - El cabezal vuelve y finaliza en la celda inicial.
    Parámetros:  
    - cantidad: Número / Cantidad de celdas que ocupará la fila.
    - direccion: Dirección / Dirección hacia dónde se hará la fila. 
    - color: Color / Color de las bolitas que conforman la fila.
    - factorDeIncremento: Número / Número que se le suma por cada celda.
    - numeroInicial: Número / Número que corresponde a la primera celda de la fila.
    Precondiciones:
    - Debe haber al menos **cantidad** - 1 celdas hacia la dirección **direccion** desde la celda actual.
    */
    Poner_DeColor_ (numeroInicial, color)
    contadorBolitasAPoner := numeroInicial
    repeat (cantidad - 1){
        Mover(direccion)
        Poner_DeColor_ (contadorBolitasAPoner + factorDeIncremento, color)
        contadorBolitasAPoner := (contadorBolitasAPoner + factorDeIncremento)
    }
        Mover_VecesAl_(cantidad - 1, opuesto (direccion))
}

procedure Poner_DeColor_(cantidadAPoner, colorAPoner){
    /*
    Propósito: Dado un número "cantidadAPoner" y un color "colorAPoner", poner tantas bolitas de un determinado color en la celda actual.
    Parámetros:
    - cantidadAPoner: número / cantidad de bolitas rojas a poner.
    - colorAPoner: color / color de las bolitas a poner.
    Precondiciones: Ninguna.
    */
    repeat (cantidadAPoner){
        Poner(colorAPoner)
    }
}

procedure Mover_VecesAl_ (cantidadAMover, direccionAMover){
    /*
    Propósito: Dado un número "cantidadAMover" y una dirección "direccionAMover", mover el cabezal tantas veces como el número dado hacia la direccón dada.
    Parámetros:
    - cantidadAMover: número / cantidad de celdas a mover el cabezal.
    - direccionAMover: dirección / dirección hacia dónde mover el cabezal.
    Precondiciones: Debe haber al menos tantas celdas como se indique en "cantidadAMover" hacia "direccionAMover"
    */   
    repeat (cantidadAMover){
        Mover(direccionAMover)
    }
}

Ejercicio 36) 

function colorMasChicoDelCualHayBolitas(){
    /*
    Propósito: 
    - Indica el color más chico para el cual haya bolitas en la celda actual.
    Precondiciones: 
    - Debe haber al menos una bolita de cualquier color en la cleda actual.
    Tipo: 
    - Color.
    Observaciones: 
    - Es un recorrido por maximo-minimo en la celda actual. Buscando el color mínimo sobre el cual hay bolitas.
    */
    colorAIndicar := minColor()
    while (not hayBolitas(colorAIndicar) && colorAIndicar /= maxColor()) {
        colorAIndicar := siguiente (colorAIndicar) 
    }
    return (colorAIndicar)
}

Ejercicio 37) 

function colorMasGrandeDelCualHayBolitas(){
    /*
    Propósito: 
    - Indica el color más grande para el cual haya bolitas en la celda actual.
    Precondiciones: 
    - Debe haber al menos una bolita de cualquier color en la cleda actual.
    Tipo: 
    - Color.
    Observaciones: 
    - Es un recorrido por maximo-minimo en la celda actual. Buscando el color máximo sobre el cual hay bolitas.
    */
    colorAIndicar := maxColor()
    while (not hayBolitas(colorAIndicar) && colorAIndicar /= minColor()) {
        colorAIndicar := previo (colorAIndicar) 
    }
    return (colorAIndicar)
}

Ejercicio 39) 

procedure IrAVaciaNumero_(numeroDeVacia){
    /*
    Propósito: 
    - Posicionar el cabezal en la celda vacía número **numeroDeVacia**. Si no hay suficientes celdas vacías, deja el cabezal en la esquina NorEste.
    Parámetros: 
    - numeroDeVacia: Número / Número de celda vacía sobre la cual posicionar el cabezal.
    Precondiciones: 
    - Ninguna.
    Observaciones: 
    - Es un recorrido de busqueda sobre las celdas del tablero. Buscando la celda vacía número **numeroDeVacia**.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    celdasVaciasYaVistas := 0
    celdasVaciasYaVistas := celdasVaciasYaVistas + unoSi_CeroSiNo(esCeldaVacia())
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && celdasVaciasYaVistas < numeroDeVacia) {
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        celdasVaciasYaVistas := celdasVaciasYaVistas + unoSi_CeroSiNo(esCeldaVacia())
    }
}

Ejercicio 40) 







