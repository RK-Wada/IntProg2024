Ejercicio 1)

function singularCon_(elementoABuscar){
    /*
    Propósito: 
    - Indicar la lista que tiene únicamente el elemento dado.
    Parámetros:
    - elementoABuscar: Elemento / Elemento a buscar en las listas.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Lista de "Elemento"
    */
    return ([elementoABuscar])
}

Ejercicio 2)

function segundoDe_(lista){
    /*
    Propósito: 
    - Indica el segundo elemento de la lista **lista**.
    Parámetros:
    - lista: Lista de "Elemento" / Lista a determinar el segundo elemento.
    Precondiciones:
    - La lista **lista** debe tener al menos 2 elementos.
    Tipo: 
    - "Elemento".
    */
    return (primero(resto(lista)))
}

Ejercicio 3) 

function esSingular_(lista){
    /*
    Propósito: 
    - Indica si la lista es singular (si tiene un único elemento).
    Parámetros:
    - lista: Lista de "Elemento" / Lista a determinar si es singular.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (not esVacia(lista) && esVacia(resto(lista)))
}

PARA EL PARCIAL 2

//1
function singularCon_(elemento){
    /*
    Propósito:
    Indica una lista con únicamente el elemento **elemento**.
    Parámetros:
    - elemento: Elemento.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de "elemento".
    */
    return ([elemento])
}

//2
function segundoDe_(lista){
    /*
    Propósito:
    - Indica el segundo elemento de la lista **lista**.
    Parámetros:
    - lista: Lista.
    Precondiciones:
    - La lista **lista** debe tener al menos 2 elementos.
    Tipo:
    - Elemento.
    */
    return (primero(resto(lista)))
}

//3
function esSingular_(lista){
    /*
    Propósito:
    - Indica si la lista **lista** es singular, es decir, tiene únicamente un elemento.
    Parámetros:
    - lista: Lista.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (not esVacia(lista) && esVacia(resto(lista)))
}

//4.A
function primerCartaDeLaMano_(mano){
    /*
    Propósito:
    - Indica la primera carta a jugar de la mano **mano**.
    Parámetros:
    - mano: Lista de "Cartas".
    Precondiciones:
    - Ninguna.
    Tipo:
    - Carta.
    */
    return (primero(mano))
}

//4.B
function segundaCartaDeLaMano_(mano){
    /*
    Propósito:
    - Indica la segunda carta a jugar de la mano **mano**.
    Parámetros:
    - mano: Lista de "Cartas".
    Precondiciones:
    - Nignuna. 
    Tipo:
    - Carta.
    */
    return (primero(resto(mano)))
}

//4.C
function tercerCartaDeLaMano_(mano){
    /*
    Propósito:
    - Indica la tercera carta a jugar de la mano **mano**.
    Parámetros:
    - mano: Lista de "Cartas".
    Precondiciones:
    - Nignuna.
    Tipo:
    - Carta.
    */
    return (primero(resto(resto(mano))))
}

//4.D
function laMano_LuegoDeRobarUnaCartaDe_(mano, mazo){
    /*
    Propósito:
    - Indica la mano resultante luego de robar la primera carta del mazo y agregarla a la mano del jugador.
    Parámetros:
    - mano: Lista de "Cartas".
    - mazo: Lista de "Cartas".
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de "Cartas"
    */
    return (mano ++ [primero(mazo)])
}

//4.E
function laMano_LuegoDeJugarUnaCarta(mano){
    /*
    Propósito:
    - Indica la mano resultnte luego de jugar la próxima carta de la mano **mano**.
    Parámetros:
    - mano: Lista de [Carta]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Carta]
    */
    return (resto(mano))
}

//4.F
function laMano_LuegoDeJugarLaSegundaCarta(mano){
    /*
    Propósito:
    - Indica la mano resultante luego de jugar la segunda carta de la mano **mano**.
    Parámetros:
    - mano: Lista de [Carta]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Carta]
    */
    return ([primero(mano)] ++ resto(resto(mano)))
}

//Ejercicio 5
//Ejercicio 5.A
function primerastresCartasDeLaTira_(tira){
    /*
    Propósito:
    - Indica las tres primeras cartas de la tira **tira**.
    Parámtros:
    - tira: Lista de [Carta]
    Precondiciones:
    - Ningnuna.
    Tipo:
    - Lista de [Carta]
    */
    return ([primero(tira), segundoDe_(tira), primero(resto(resto(tira)))])
}

//5.B
function laMano_TieneJugadaParaAgregarALaTira_(mano, tira){
    /*
    Propósito:
    - Indica si la primera carta que puede jugar el jugador puede ser agregada en la tira. 
    Parámetros:
    - mano: Lista de [Carta]
    - tira: Lista de [Carta]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (palo(primero(mano)) /= palo(primero(tira)) && numero(primero(mano)) < numero(primero(tira)))
}

//5.C
function laTira_DespuesDeJugar_(tira, carta){
    /*
    Propósito:
    - Indica la tira que resulta de jugar esa carta en la tira **tira**. 
    Parámetros:
    - tira: Lista de [Carta]
    - carta: Carta.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Carta]
    */
    return (choose cons (carta, tira) when (palo(carta) /= palo(primero(tira)) && numero(carta) < numero(primero(tira))))
                   BOOM otherwise)
}

//Ejercicio 2.A
function sigueRectaEn_(pista){
    /*
    Propósito:
    - Indica si el siguiente tramo es una recta.
    Parámetros:
    - pista: Lista de [Direcciones]
    Precondiciones:
    - Debe existir un siguiente tramo en la pista **pista**.
    Tipo:
    - Booleano.
    */
    return (primero(pista) == primero(resto(pista)))
}

//2.B
function sigueCurvaADerechaEn_(pista){
    /*
    Propósito:
    - Indica si el siguiente tramo es una curva a la derecha.
    Parámetros:
    - pista: Lista de [Direcciones]
    Precondiciones:
    - Debe existir un siguiente tramo en la pista **pista**.
    Tipo:
    - Booleano.
    */
    return (primero(resto(pista)) == siguiente(primero(pista)))
}

//2.C
function sigueCurvaAIzquierdaEn_(pista){
    /*
    Propósito:
    - Indica si el siguiente tramo es una curva a la izquierda.
    Parámetros:
    - pista: Lista de [Direcciones]
    Precondiciones:
    - Debe existir un siguiente tramo en la pista **pista**.
    Tipo:
    - Booleano.
    */
    return (primero(resto(pista)) == previo(primero(pista)))
}

//2.D
function haySiguienteTramoEn_(pista){
    /*
    Propósito:
    - Indica si la pista **pista** tiene un siguiente tramo.
    Parámetros:
    - pista: Lista de [Direcciones]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (not esVacia(resto(resto(pista))))
}

//2.E
function sigueUnaCurvaEn_(pista){
    /*
    Propósito:
    - Indica si el siguiente tramo es una curva.
    Parámetros:
    - pista: Lista de [Direcciones]
    Precondiciones:
    - Debe existir un siguiente tramo en la pista **pista**.
    Tipo:
    - Booleano.
    */
    return (sigueCurvaADerechaEn_(pista) || sigueCurvaAIzquierdaEn_(pista))
}

//2.F
function siguienteTramoEn_EsValido(pista){
    /*
    Propósito:
    - Indica si el siguiente tramo en la pista **pista** es válido, es decir, es una recta o una curva.
    Parámetros:
    - pista: Lista de [Direcciones]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (sigueRectaEn_(pista) || sigueUnaCurvaEn_(pista))
}

//Ejercicio 6
function listaCon_Repetido_Veces(elemento, numero){
    /*
    Propósito:
    - Describe una lista con el elemento **elemento** repetido **numero** de veces dentro.
    Parámetros:
    - elemento: Elemento.
    - numero: Número.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Elementos]
    */
    listaActual := []
    repeat(numero){
        listaActual := listaActual ++ [elemento]
    }
    return (listaActual)
}

//7
function listaDesde_Hasta_(primerElemento, segundoElemento){
    /*
    Propósito:
    - Describe la lista que va del **primerElemento** al **segundoElemento**, pasando por cada elemento intermedio.
    Parámetros:
    - primerElemento: Elemento.
    - segundoElemento: Elemento.
    Precondiciones:
    - **primerElemento** y **segundoElemento** no pueden ser iguales.
    - **primerElemento** y **segundoElemento** deben ser del mismo tipo.
    */
    elementoActual := primerElemento
    listaActual := [primerElemento]
    while (elementoActual /= segundoElemento){
        elementoActual := siguiente(primerElemento)
        listaActual := listaActual ++ [elementoActual]
    }
    return (listaActual)
}

//8
function longitudDe_(lista){
    /*
    Propósito:
    - Indica la cantidad de elementos dentro de la lista **lista**.
    Parámetros:
    - lista: Lista de [Elementos]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de acumulación sobre la lista **lista**, acumulando la cantidad de elementos que hay dentro de la misma.
    */
    cantidadDeElementosActual := 0
    listaActual := lista
    while (not esVacia(listaActual)){
        listaActual := resto(listaActual)
        cantidadDeElementosActual := cantidadDeElementosActual + 1
    }
    return (cantidadDeElementosActual)
}

//9
function sumatoriaDe_(listaDeNumeros){
    /*
    Propósito:
    - Indica la suma de todos los elementos de la lista **listaDeNumeros**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de procesado sobre la lista **listaDeNumeros**, sumando todos los elementos de la misma.
    */
    listaActual := listaDeNumeros
    sumaActual := 0
    while (not esVacia(listaActual)){
        sumaActual := sumaActual + primero(listaActual)
        listaActual := resto(listaActual)
    }
    return (sumaActual)
}

//10
function productoriaDe_(listaDeNumeros){
    /*
    Propósito:
    - Indica el producto de todos los elementos de la lista **listaDeNumeros**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    Observaciones: 
    - Es un recorrido de procesado sobre la lista **listaDeNumeros**, multiplicando todos los elementos de la misma.
    */
    listaActual := listaDeNumeros
    productoActual := primero(listaDeNumeros)
    while (not esVacia(listaActual)){
        productoActual := productoActual * primero(listaActual)
        listaActual := resto(listaActual)
    }
    return (productoActual)
}

//11 
function puntosEn_(mano){
    /*
    Propósito:
    - Indica la cantidad de puntos que el jugador tiene en la mano **mano**. 
    Parámetros:
    - mano: Lista de [Cartas]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de acumulación sobre las Cartas de la mano **mano**. Acumulando los valores de las cartas.
    */
    puntosActuales := 0
    listaActual := mano
    while (not esVacia(listaActual)){
        puntosActuales := puntajeCarta_(primero(listaActual))
        listaActual := resto(listaActual)
    }
    return (puntosActuales)
}

function puntajeCarta_(carta){
    /*
    Propósito:
    - Indica el puntaje de la carta **carta**.
    Parámetros:
    - carta: Carta.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    */
    return (choose 20 when (esNegra(carta) == True)
                   numero(carta) otherwise)
}

//12
function elementosDe_AumentadosEn_(listaDeNumeros, cantidadAAumentar){
    /*
    Propósito:
    - Describe la lista en dónde cada elemento de la lista **listaDeNumeros** fue aumentado **cantidadAAumentar**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    - cantidadAAumentar: Número.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Numeros]
    Observaciones:
    - EEEEEEEEEEEEEEEEEEEEEEEEEEEEE
    */
    listaAumentada := []
    listaActual := listaDeNumeros
    while (not esVacia(listaActual)){
        listaAumentada := listaAumentada ++ [primero(listaActual) + cantidadAAumentar]
        listaActual := resto(listaActual)
    }
    return (listaAumentada)
}

//13
function opuestasDe_(listaDeDirecciones){
    /*
    Propósito:
    - Describe una lista con las direcciones opuestas de la lista **listaDeDirecciones**.
    Parámetros:
    - listaDeDirecciones:Lista de [Direcciones]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Direcciones]
    Observaciones:
    - Es un recorrido de procesamiento sobre la lista **listaDeDirecciones**, describiendo el opuesto de cada elemento de la misma.
    */
    listaOpuesta := []
    listaActual := listaDeDirecciones
    while (not esVacia(listaActual)){
        listaOpuesta := listaOpuesta ++ [opuesto(primero(listaActual))]
        listaActual := resto(listaActual)
    }
    return (listaOpuesta)
}

//14
function siguientesDe_(listaDePrimitivos){
    /*
    Propósito:
    - Describe la lista donde cada elemento es el siguiente de los de la lista **listaDePrimitivos**.
    Parámetros:
    - listaDePrimitivos: Lista de [Elementos]
    Precondiciones:
    - La lista **listaDePrimitivos** debe ser de elementos primitivos, es decir, de colores, direcciones, números o Booleanos.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de procesamiento sobre los elementos de la lista **listaDePrimitivos**, reemplazando los elementos por sus siguientes.
    */
    listaDeSiguientes := []
    listaActual := listaDePrimitivos
    while (not esVacia(listaActual)){
        listaDeSiguientes := listaDeSiguientes ++ [siguiente(primero(listaActual))]
        listaActual := resto(listaActual)
    }
    return (listaDeSiguientes)
}

//15
function transformadasTodasEnOro_(lista){
    /*
    Propósito:
    - Describe la lista de cartas en dónde cada una conserva el valor que tenía en **lista** pero se cambia el tipo de palo por "Oro".
    Parámetros:
    - lista: Lista de [Cartas]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Cartas]
    Observaciones:
    - Es un recorrido de procesamiento sobre las cartas de la lista **lista**, cambiando el palo de cada carta dentro de la misma por "Oro".
    */
    listaDeOro := []
    listaActual := lista
    while (not esVacia(listaActual)){
        listaDeOro := listaDeOro ++ [convertirEnOro_(primero(lista))]
        listaActual := resto(listaActual)
    }
    return (listaDeOro)
}

function convertirEnOro_(carta){
    /*
    Propósito:
    - Indica la carta **carta** con el palo cambiado a "Oro".
    Parámetros:
    - carta: Carta
    Precondiciones:
    - Ninguna.
    Tipo:
    - Carta.
    */
    return (Carta (carta | palo <- Oros))
}

//16
function reversoDe_(lista){
    /*
    Propósito:
    - Describe el reverso de la lista **lista**.
    Parámetros:
    - lista: Lista de [Elementos]
    Precondiciones:
    - Nignuna.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de procesamiento sobre los elementos de la lista **lista**, cambiando el orden de los elementos de la misma, poniendo la lista en reversa.
    */
    listaReversa := []
    listaActual := lista
    while (not esVacia(listaActual)){
        listaReversa := [primero(listaActual)] ++ listaReversa
        listaActual := resto(listaActual)
    }
    return (listaReversa)
}

//17
function paresDe_(listaDeNumeros){
    /*
    Propósito:
    - Describe una lista solo con los números pares de la lista **listaDeNumeros**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Numeros]
    Observaciones:
    - Es un recorrido de acumulación sobre los números de la lista **listaDeNumeros**, acumulando los números pares.
    */
    listaDePares := []
    listaActual := listaDeNumeros
    while (not esVacia(listaActual)){
        if esPar_(primero(listaActual)) then {
            listaDePares := listaDePares ++ primero(listaActual)
        }
        listaActual := resto(listaActual)
    }
    return (listaDePares)
}

function esPar_(numero){
    /*
    Propósito:
    - Indica si el número **numero** es par.
    Parámetros:
    - numero: Número.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return ((numero mod 2) == 0) 
}

//18
function imparesDe_(listaDeNumeros){
    /*
    Propósito:
    - Describe una lista solo con los números impares de la lista **listaDeNumeros**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Numeros]
    Observaciones:
    - Es un recorrido de acumulación sobre los números de la lista **listaDeNumeros**, acumulando los números impares.
    */
    listaDeImpares := []
    listaActual := listaDeNumeros
    while (not esVacia(listaActual)){
        if not esPar_(primero(listaActual)) then {
            listaDeImpares := listaDeImpares ++ primero(listaActual)
        }
        listaActual := resto(listaActual)
    }
    return (listaDeImpares)
}

//19
function elementosDe_SinAparicionesDe_(lista, elemento){
    /*
    Propósito:
    - Describe una lista con todos los elementos de la lista **lista** que no sean **elemento**.
    Parámetros:
    - lista: Lista de [Elementos]
    - elemento: Elemento.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de procesamiento sobre los elementos de la lista **lista**, removiendo todos los elementos **elementos** de la misma.
    */
    listaRemovida := []
    listaActual := lista
    while (not esVacia(listaActual)){
        if (primero(listaActual) /= elemento) then {
            listaRemovida := listaRemovida ++ [primero(listaActual)]
        }
        listaActual := resto(listaActual)
    }
    return (listaRemovida)
}

//20
function soloLasFigurasDe_(listaDeCartas){
    /*
    Propósito:
    - Describe una lista con solo las cartas de **listaDeCartas** que son figuras.
    Parámetros:
    - listaDeCartas: Lista de [Cartas]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Cartas]
    Observaciones:
    - Es un recorrido de acumulación sobre las Cartas de la lista **listaDeCartas**, acumulando las cartas que sean figuras.
    */
    listaDeFiguras := []
    listaActual := listaDeCartas
    while (not esVacia(listaActual)){
        if (esFigura_(primero(listaActual))) then {
            listaDeFiguras := listaDeFiguras ++ [primero(listaActual)]
        }
        listaActual := resto(listaActual)
    }
    return(listaDeFiguras)
}

function esFigura_(carta){
    /*
    Propósito:
    - Indica si la carta **carta** es una figura, es decir, su número es 10, 11 o 12.
    Parámetros:
    - carta: Carta.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (numero(carta) == 10 || numero(carta) == 11 || numero(carta) == 12)
}

//21
function contiene_A_(lista, elemento){
    /*
    Propósito:
    - Indica si el elemento **elemento** se encuentra en la lista **lista**.
    Parámetros:
    - lista: Lista de [Elementos]
    - elemento: Elemento
    Precondiciones:
    - **elemento** debe ser del mismo tipo que los elementos dentro de **lista**.
    Tipo:
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre los elementos de la lista **lista**, búscando el elemento **elemento**, sin saber si está.
    */
    listaActual := lista
    contieneONo := False
    while (not esVacia(listaActual)){
        if (primero(listaActual) == elemento) then {
            contieneONo := True
        }
        listaActual := resto(listaActual)
    }
    return (contieneONo)
}

//22
function indiceEn_De_(lista, elemento){
    /*
    Propósito:
    - Indica en qué ubicación de la lista **lista** se encuentra el elemento **elemento**.
    Parámetros:
    - lista: Lista de [Elementos]
    - elemento: Elemento.
    Precondiciones:
    - **elemento** debe ser del mismo tipo que los elementos dentro de la lista **lista**.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de búsqueda sobre los elementos de la lista **lista**, buscando el elemento **elemento**, sabiendo que está.
    */
    puestoActual := 1
    listaActual := lista
    while (not esVacia(listaActual) && puestoActual /= elemento){
        listaActual := resto(listaActual)
        puestoActual := puestoActual + 1
    }
    return (puestoActual)
}

//23
function hayAlgunoDe_Entre_Y_(listaDeNumeros, primerNumero, segundoNumero){
    /*
    Propósito:
    - Indica si algún número de la lista **lista** se encuentra entre los números **primerNumero** y **segundoNumero**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    - primerNumero: Número.
    - segundoNumero: Número.
    Precondiciones:
    - **primerNumero** y **segundoNumero** no deben ser iguales.
    Tipo:
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre los elementos de la lista **lista**.
    */
    listaActual := lista
    numeroActual := primero(lista)
    while (not esVacia(listaActual) && not(estaEnMedio_De_Y_(numeroActual, primerNumero, segundoNumero)){
        listaActual := resto(listaActual)
        numeroActual := primero(listaActual)
    }
    return (estaEnMedio_De_Y_(numeroActual, primerNumero, segundoNumero))
}

//Posible 23
function hayAlgunoDe_Entre_Y_(listaDeNumeros, primerNumero, segundoNumero){
    /**/
    listaActual := lista
    while (not esVacia(listaActual) && not (primero(listaActual) > primerNumero) && not (primero(listaActual) < segundoNumero)){
        listaActual := resto(listaActual)
    } 
    return (primero(listaActual) > primerNumero && primero(listaActual) < segundoNumero)
}

//24
function hayAlgunAsEn_(listaDeCartas){
    /*
    Propósito:
    - Indica si en la lista **listaDeCartas** hay algún as, es decir, una carta con número 1.
    Parámetros:
    - listaDeCartas: Lista de [Cartas]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre los elementos de la lista **listaDeCartas**, buscando alguna carta con el número 1.
    */
    listaActual := listaDeCartas
    while (not esVacia(listaActual) && numero(primero(listaActual)) /= 1){
        listaActual := resto(listaActual)
    }
    return (numero(primero(listaActual)) == 1)
}

//25
function minimoEn_(listaDeNumeros){
    /*
    Propósito:
    - Indica el número más chico en la lista **lista**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de máximos y mínimos sobre los elementos de la lista **listaDeNumeros**, buscando el número más chico.
    */
    listaActual := listaDeNumeros
    numeroMasChico := primero(listaActual)
    while (not esVacia(listaActual)) {
        listaActual := resto(listaActual)
        numeroMasChico := minimoEntre_Y_(primero(listaActual), numeroMasChico)
    }
    return (numeroMasChico)
}

//26
function maximoEn_(listaDeNumeros){
    /*
    Propósito:
    - Indica el número más grande en la lista **lista**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de máximos y mínimos sobre los elementos de la lista **listaDeNumeros**, buscando el número más grande de la misma.
    */
    listaActual := listaDeNumeros
    numeroMasGrande := primero(listaActual)
    while (not esVacia(listaActual)) {
        listaActual := resto(listaActual)
        numeroMasGrande := maximoEntre_Y_(primero(listaActual), numeroMasChico)
    }
    return (numeroMasGrande)
}

//27
function laMejorCartaEn_ParaTira_(listaDeCartas, tira){
    /*
    Propósito:
    - Indica la mejor carta de **listaDeCartas** para sumar a la tira **tira**.
    Parámetros:
    - listaDeCartas: Lista de [Cartas]
    - tira: Lista de [Cartas]
    Precondiciones:
    - La primera carta de **listaDeCartas** debe ser apta .
    Tipo:
    - Carta
    Observaciones: 
    - Es un recorrido de máximos y mínimos, bucando la mejor carta para sumar a la tira **tira**.
    */
    listaActual := listaDeCartas
    if (numero(primero(listaActual)) < numero(primero(tira)) && palo(primero(listaActual)) /= palo(primero(tira))) then {
        mejorCartaHastaAhora := primero(listaActual)
    }
    while (not esVacia(listaActual)) {
        listaActual := resto(listaActual)
        if (numero(primero(listaActual)) < numero(primero(tira)) && palo(primero(listaActual)) /= palo(primero(tira))) then {
            mejorCartaHastaAhora := mejorEntre_Y_(mejorCartaHastaAhora, primero(listaActual)
        }
    }
    return (mejorCartaHastaAhora)
}

function mejorEntre_Y_(primerCarta, segundaCarta){
    /*
    Propósito:
    - Indica la mejor carta entre **primerCarta** y **segundaCarta**.
    Parámetros:
    - primerCarta: Carta
    - segundaCarta: Carta
    Precondiciones:
    - **primerCarta** y **segundaCarta** deben ser del mismo tipo.
    Tipo:
    - Carta.
    */
    return (choose primerCarta when (valor_(palo(primerCarta)) > valor_(palo(segundaCarta))
                   segundaCarta otherwise)
}

function valor_(palo){
    /*
    Propósito:
    - Indica el valor del palo **palo**.
    Parámetros:
    - palo: String
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    */
    return (choose 4 when (palo == Oro)
                   3 when (palo == Copas)
                   2 when (palo == Espadas)
                   1 otherwise)
}

//28
function elementosEn_Hasta_(lista, indice){
    /*
    Propósito:
    - Describe una lista de todos los elementos en la lista **lista** antes del **indice**
    Parámetros:
    - lista: Lista de [Elementos]
    - indice: Elemento.
    Precondiciones:
    - **indice** debe ser del mismo tipo que los elementos dentro de la lista **lista**.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de acumulación sobre los elementos de la lista **lista**, acumulando los elementos que se encuentran antes del elemento **indice**.
    */
    listaActual := lista
    elementoActual := 1
    listaPrevia := []
    while (not esVacia(listaActual) && not (elementoActual == indice)){
        listaPrevia := listaPrevia ++ primero(listaActual)
        listaActual := resto(listaActual)
        elementoActual := elementoActual + 1
    }
    return (listaPrevia)
}

//29
function elementosEn_Desde_(lista, indice){
    /*
    Propósito:
    - Describe una lista de elementos con todos aquellos elementos de la lista **lista** que se encuentren luego del **indice**.
    Parámetros:
    - lista: Lista de [Elementos]
    - indice: Elemento
    Precondiciones:
    - **indice** debe ser del mismo tipo que los elementos dentro de la lista **lista**.
    Observaciones:
    - Es un recorrido de acumulación sobre los elementos de la lista **lista**, acumulando los elementos que se encuentren luego del elemento **indice**.
    */
    listaActual := lista
    elementoActual := 1
    listaPosterior := []
    while (not esVacia(listaActual)) {
        if (primero(listaActual) > indice) then {
            listaPosterior := listaPosterior ++ primero(listaActual)
        }
        listaActual := resto(listaActual)
    }
    return (listaPosterior)
}

//30
function elementosEn_SinPrimeraAparicionDe_(lista, elemento){
    /*
    Propósito:
    - Describe una lista sin la primera aparición del elemento **elemento** dentro de la lista **lista**.
    Parámetros:
    - lista: Lista de [Elementos]
    - elemento: Elemento.
    Precondiciones:
    - **indice** debe ser del mismo tipo que los elementos dentro de la lista **lista**.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de procesamiento sobre los elementos de la lista **lista**, eliminando la primera aparición del elemento **elemento**.
    */
    listaNueva := []
    listaActual := lista
    primeraAparicionElemento := 1
    while (not esVacia(listaActual) && not primero(listaActual) == elemento){
        listaActual := resto(listaActual)
        primeraAparicionElemento := primeraAparicionElemento + 1
    }
    return(elementosEn_Hasta_(lista, primeraAparicionElemento) ++ elementosEn_Desde_(lista, primeraAparicionElemento))
}

//31
function sinDuplicados_(lista){
    /*
    Propósito:
    - Describe una lista con los elementos de la lista **lista** pero sin duplicados.
    Parámetros:
    - lista: Lista de [Elementos]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de acumulación sobre los elementos de la lista **lista**. Acumulando los elementos que no se encuentren duplicados.
    */
    listaActual := lista
    listaNueva := []
    while (not esVacia(listaActual)){
        listaNueva := listaNueva ++ singular_Si_(primero(listaActual), not contiene_A_(listaNueva, primero(listaActual)))
        listaActual := resto(listaActual)
    }
    return(listaNueva)
}

//32.B
function laLista_Clonada_Veces(lista, numeroClonacion){
    /*
    Propósito:
    - Describe la lista resultante de clonar la lista **lista** tantas veces como se indique en **numeroClonacion**.
    Parámetros:
    - lista: Lista de [Elementos]
    - numeroClonacion: Número.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Elementos]
    */
    listaNueva := []
    listaActual := 0
    while (listaActual /= numeroClonacion){
        listaNueva := listaNueva ++ lista
        listaActual := listaActual + 1
    }
    return (listaNueva)
}

//32.C
function losElementosDe_Clonados_Veces(lista, numeroClonacion){
    /*
    Propósito:
    - Describe una lista que contiene los elementos dados en el orden de la lista **lista**, pero repetidos cada uno la cantidad de veces **numeroClonacion**.
    Parámetros:
    - lista: Lista de [Elementos]
    - numeroClonacion: Número.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Elementos]
    */
    listaNueva := []
    foreach elemento in lista {
        listaNueva := listaNueva ++ listaCon_Repetido_Veces(elemento, numeroClonacion)
    }
    return (listaNueva)
}

//33
function lista_HomologadaPorDebajoDe_A_(listaDeNumeros, umbral, default){
    /*
    Propósito:
    - Describe una lista de números que está basada en la lista **listaDeNumeros** y que se incluyen los números que son mayores o iguales al **umbral** permaneciendo igual y los que son menores son reemplazados por el valor default.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    - umbral: Número.
    - default: Número.
    Precondiciones:
    - **umbral** y **default** deben ser del tipo número.
    Tipo:
    - Lista de [Numeros]
    Observaciones:
    */
    listaNueva := []
    foreach numero in listaDeNumeros {
        if (numero >= umbral) then {
            listaNueva := listaNueva ++ [numero]
        }
        else {
            listaNueva := listaNueva ++ [default]
        }
    }
    return (listaNueva)
}

//34
function sinDuplicados_(lista){
    /*
    Propósito:
    - Describe una lista con los elementos de la lista **lista** pero sin duplicados, conservando la primera aparición de los elementos de la lista **lista**.
    Parámetros:
    - lista: Lista de [Elementos]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de procesamiento sobre la lista **lista**, eliminando los duplicados luego de la primera aparición de cada elemento.
    */
    listaNueva := []
    foreach elemento in lista {
        listaNueva := listaNueva ++ singular_Si_(elemento, contiene_A_(listaNueva, elemento))
    }
    return (listaNueva)
}

//35.A
function interseccionDe_Con_(primerLista, segundaLista){
    /*
    Propósito:
    - Describe la lista de todos los elementos que aparecen en ambas lista **primerLista** y **segundaLista**.
    Parámetros:
    - primerLista: Lista de [Elementos]
    - segundaLista: Lista de [Elementos]
    Precondiciones:
    - **primerLista** y **segundaLista** deben ser del mismo tipo. 
    Tipo:
    - Lista de [Elementos]
    Observaciones:
    - Es un recorrido de filtrado sobre las listas **primerLista** y **segundaLista**, filtrando los elementos que no se encuentren en ambas listas.
    */
    nuevaLista := []
    foreach elemento in primerLista {
        nuevaLista := nuevaLista ++ singular_Si_(elemento, contiene_A_(segundaLista, elemento))
    }
    return (sinDuplicados_(nuevaLista)
}

//35.B
function unionDe_Con_(primerLista, segundaLista){
    /*
    Propósito:
    - Describe una lista resultante de unir las listas **primerLista** y **segundaLista**, sin elementos repetidos.
    Parámetros:
    - primerLista: Lista de [Elementos]
    - segundaLista: Lista de [Elementos]
    Precondiciones:
    - **primerLista** y **segundaLista** deben ser del mismo tipo.
    Tipo:
    - Lista de [Elementos]
    */
    return (sinDuplicados_(primerLista ++ segundaLista))
}

//36
function lista_EstaIncluidaEn_(primerLista, segundaLista){
    /*
    Propósito:
    - Describe si todos los elementos de la lista **primerLista** se encuentran contenidos en la lista **segundaLista**.
    Parámetros:
    - primerLista: Lista de [Elementos]
    - segundaLista: Lista de [Elementos]
    Precondiciones:
    - **primerLista** y **segundaLista** deben ser del mismo tipo.
    Tipo:
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre los elementos de las listas **primerLista** y **segundaLista**, buscando si algún elemento de la lista **primerLista** no se encuentra en la lista **segundaLista**.
    */
    listaDeNoIncluidos := []
    foreach elemento in primerLista {
        listaDeNoIncluidos := listaDeNoIncluidos ++ singular_Si_(elemento, contiene_A_(segundaLista, elemento))
    }
    return (esVacia(listaDeNoIncluidos))
}

//37
function estaOrdenada_(listaDeNumeros){
    /*
    Propósito:
    - Indica si la lista **listaDeNumeros** está ordenada de menor a mayor, es decir, cada elemento es menor o igual al que le sigue.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    Observaciones:
    - Es un recorrido de búsqueda sobre los elementos de la lista **listaDeNumeros**, buscando algún elemento que no cumpla con el orden.
    */
    listaActual := listaDeNumeros
    while (not esVacia(listaActual) && primero(listaActual) <= primero(resto(listaActual))){
        listaActual := resto(listaActual) 
    }
    return (primero(listaActual) <= primero(resto(listaActual)))
}

//38
//Es igual al 30.

//39.A
function minimoElementoDe_(listaDeNumeros){
    /*
    Propósito:
    - Indica el elemento más chico que se encuetra en la lista **listaDeNumeros**.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Debe haber al menos un elemento que sea más chico que los demás.
    - La lista **listaDeNumeros** no debe ser vacía.
    Tipo:
    - Número.
    Observaciones:
    - Es un recorrido de máximos y mínimos sobre los elementos de la lista **listaDeNumeros**, buscando el elemento más chico de la misma.
    */
    listaActual := listaDeNumeros
    numeroMasChico := primero(listaActual)
    while (not esVacia(listaActual)){
        listaActual := resto(listaActual)
        numeroMasChico := minimoEntre_Y_(numeroMasChico, primero(listaActual)
    }
    return (numeroMasChico)
}

//39.B
function sinElMinimoElemento_(listaDeNumeros){
    /*
    Propósito:
    - Describe la lista que se obtiene de eliminar una única vez el elemento más chico.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Debe haber al menos un elemento que sea más chico que los demás.
    - La lista **listaDeNumeros** no debe ser vacía.
    Tipo:
    - Lista de [Numeros]
    Observaciones:
    - Es un recorrido de filtrado sobre los elementos de la lista **listaDeNumeros**, quitando una vez el elemento más chico.
    */
    return (elementosEn_SinPrimeraAparicionDe_(listaDeNumeros, minimoElementoDe_(listaDeNumeros))
}

//39.C
function lista_ordenada(listaDeNumeros){
    /*
    Propósito:
    - Describe la lista con los mismos elementos que la lista **listaDeNumeros**, pero ordenados de menor a mayor.
    Parámetros:
    - listaDeNumeros: Lista de [Numeros]
    Precondiciones:
    - Ninguna.
    Tipo:
    - Lista de [Numeros]
    Observaciones:
    - Es un recorrido de transformación sobre los elementos de la lista, ordenando los elementos dentro de la misma de menor a mayor.
    */
    
}
