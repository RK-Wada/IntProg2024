Ejercicio 1)

type DiaDeLaSemana is variant {
    /*
    Propósito: 
    - Modelar los días de la semana.
    */
    case Lunes     {}
    case Martes    {}
    case Miercoles {}
    case Jueves    {}
    case Viernes   {}
    case Sabado    {}
    case Domingo   {}
}

Ejercicio 1, a) 

function diaSiguiente_ (dia){
    /*
    Propósito: 
    - Indica el día siguiente a **dia**.
    Parámetros: 
    - dia: DiaDeLaSemana
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - DiaDeLaSemana
    */
    return (choose Lunes when (dia == Domingo)
                   Martes when (dia == Lunes)
                   Miercoles when (dia == Martes)
                   Jueves when (dia == Miercoles)
                   Viernes when (dia == Jueves)
                   Sabado when (dia == Viernes)
                   Domingo otherwise)
}

Ejercicio 1, b) 

function diaPrevio_ (dia){
    /*
    Propósito: 
    - Indica el día previo al día **dia**.
    Parámetros: 
    - dia: DiaDeLaSemana.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - DiaDeLaSemana.
    */
    return (choose Lunes when (dia == Martes)
                   Martes when (dia == Miercoles)
                   Miercoles when (dia == Jueves)
                   Jueves when (dia == Viernes)
                   Viernes when (dia == Sabado)
                   Sabado when (dia == Domingo)
                   Domingo otherwise)
}

Ejercicio 1, c) 

function esDiaDeFinDeSemana_(dia){
    /*
    Propósito:
    - Indica si el día **dia** es día de fin de semana.
    Parámetros:
    - dia: DiaDeLaSemana.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    Observaciones:
    - Los días de fin de semana son Sabado y Domingo.
    */
    return (dia == Sabado || dia == Domingo)
}

Ejercicio 2) 

type PartidoPolitico is variant {
    /*
    Propósito: 
    - Modelar los partidos políticos del país.
    */
    case DemocraciaPorLaVerdad  {}
    case UnidosPorLaRepublica   {}
    case LiberalesPorLaLibertad {}
    case IzquierdaDeLosObreros  {}
}

Ejercicio 2, a) 

function tieneMasVotantes_Que_(primerPartido, segundoPartido){
    /*
    Proposito:
    - Indica si el **primerPartido** tiene más votantes que el **segundoPartido**.
    Parámetros:
    - primerPartido: PartidoPolitico 
    - segundoPartido: PartidoPolitico
    Precondiciones:
    - **primerPartido** y **segundoPartido** deben ser distintos partidos.
    - **primerPartido** y **segundoPartido** deben tener distinta cantidad de votos.
    Tipo:
    - Booleano.
    */
    return (cantidadDeVotosDe_(primerPartido) > cantidadDeVotos_(segundoPartido))
}

Ejercicio 2, b) 

function elQueTieneMasVotos(){
    /*
    Propósito:
    - Indica el partido político con más votos.
    Precondiciones:
    - Debe haber un partido político que tenga más votos que todo el resto.
    Tipo:
    - PartidoPolitico
    Observaciones:
    - Es un recorrido de búsqueda sobre los partidos políticos, buscando el partido con la mayor cantidad de votos.
    */
    partidoActual := DemocraciaPorLaVerdad
    partidoConMasVotos := partidoActual
    while (partidoActual /= IzquierdaDeLosObreros) {
        partidoActual := partidoSiguienteA_(partidoActual)
        partidoConMasVotos := maximoEntrePartido_Y_(partidoConMasVotos, partidoActual)
    }
    return (partidoConMasVotos)
}

function partidoSiguienteA_(partidoPolitico){
    /*
    Propósito:
    - Indica el partido político siguiente al partido **partidoPolitico**.
    Parámetros:
    - partidoPolitico: PartidoPolitco
    Precondiciones:
    - Ninguna.
    Tipo: 
    - PartidoPolitico.
    */
    return (choose DemocraciaPorLaVerdad when (partidoPolitico == IzquierdaDeLosObreros)
                   UnidosPorLaRepublica when (partidoPolitico == DemocraciaPorLaVerdad)
                   LiberalesPorLaLibertad when (partidoPolitico == UnidosPorLaRepublica)
                   IzquierdaDeLosObreros otherwise)
}

function maximoEntrePartido_Y_(primerPartido, segundoPartido){
    /*
    Propósito:
    - Indica el partido con más votantes entre el **primerPartido** y el **segundoPartido**.
    Parámetros:
    - primerPartido: PartidoPolitico 
    - segundoPartido: PartidoPolitico
    Precondiciones:
    - **primerPartido** y **segundoPartido** deben ser distintos partidos.
    - **primerPartido** y **segundoPartido** deben tener distinta cantidad de votos.
    Tipo:
    - PartidoPolitico.
    */
    return (choose primerPartido when (tieneMasVotantes_Que_(primerPartido, segundoPartido))
                   segundoPartido otherwise)
}

Ejercicio 2, c) 

function habraBallotage(){
    /*
    Propósito:
    - Indica si en las elecciones habrá ballotage.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    Observaciones:
    - El ballotage se da cuando el partido con más votos no acumula más del 50% de los votos totales y no hay una diferencia de más del 10% sobre entre el primero y el segundo candidato.
    */
    return (cantidadDeVotosDe_(elQueTieneMasVotos()) > cantidadDeVotosTotal() div 2 && diferenciaEntrePrimeroYSegundo() < cantidadDeVotosTotal() * 0.1)
}

function cantidadDeVotosTotal(){
    /*
    Propósito:
    - Indica la cantidad total de votos entre todos los partidos políticos.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    */
    return (cantidadDeVotosDe_(DemocraciaPorLaVerdad) + cantidadDeVotosDe_(UnidosPorLaRepublica) + cantidadDeVotosDe_(LiberalesPorLaLibertad) + cantidadDeVotosDe_(IzquierdaDeLosObreros))
}

function segundoConMasVotos(){
    /*
    Propósito:
    - Indica el segundo partido político con más votos. 
    Precondiciones:
    - Debe haber un segundo partido que tenga más votos que otros 2 pero menos votos que el primero.
    Tipo: 
    - PartidoPolitico.
    Observaciones:
    - Es un recorrido de búsqueda sobre los partidos políticos, buscando el segundo partido con más votos.
    */
    partidoActual := DemocraciaPorLaVerdad
    if (partidoActual == elQueTieneMasVotos()) then {
        partidoActual := partidoSiguienteA_(partidoActual)
    }
    segundoPartidoConMasVotos := partidoActual
    while (partidoActual /= IzquierdaDeLosObreros){
        partidoActual := partidoSiguienteA_(partidoActual)
        if (partidoActual /= elQueTieneMasVotos()) then {
            segundoPartidoConMasVotos := maximoEntrePartido_Y_(segundoPartidoConMasVotos, partidoActual)
        }
    }
    return (segundoPartidoConMasVotos)
}

function diferenciaEntrePrimeroYSegundo(){
    /*
    Propósito:
    - Indica la diferencia entre el partido político con más votos y el segundo partido con más votos.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número.
    */
    return (cantidadDeVotosDe_(elQueTieneMasVotos()) - cantidadDeVotosDe_(segundoConMasVotos()))
}

Ejercicio 3) 

type Carta is record {
    /*
    Propósito: 
    - Modela cartas españolas para el truco.
    Inv. Rep: 
    - El número está entre el 1 y el 7 o el 10 y el 12.
    */
    field numero  // Un valor del tipo Número
    field palo    // Un valor del tipo Palo.
}

type Palo is variant {
    /*
    Propósito: 
    - Modela los palos de las cartas españolas.
    */
    Oros    {}
    Espadas {}
    Bastos  {}
    Copas   {}
}

Ejercicio 3, a) 

function anchoDeEspadas(){
    /*
    Propósito: 
    - Indica la carta de 1 de espadas.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Carta.
    */
    return (Carta(numero <- 1, palo <- Espadas))
}

Ejercicio 3, b) 

function anchoDeBastos(){
    /*
    Propósito: 
    - Indica la carta de 1 de bastos.
    Precondición:
    - Ninguna.
    Tipo: 
    - Carta
    */
    return (Carta(numero <- 1, palo <- Bastos))
}

Ejercicio 3, c) 

function laCarta_De_ (numeroDeLaCarta, paloDeLaCarta){
    /*
    Propósito: 
    - Indica la carta de número **numeroDeLaCarta** del palo **paloDeLaCarta**.
    Parámetros: 
    - numeroDeLaCarta: Número / Número de la carta.
    - paloDeLaCarta: Palo / Palo de la carta.
    Precondiciones: 
    - **numeroDeLaCarta** Debe ser un número entre 1 y 7 o 10 y 12.
    Tipo: 
    - Carta.
    */
    return (Carta(numero <- numeroDeLaCarta, palo <- paloDeLaCarta))
}

Ejercicio 3, d) 

function esUnAncho_(numero){
    /*
    Propósito: 
    - Indica si el número **numero** es un ancho.
    Parámetros: 
    - numero: Número / Número de la carta.
    Precondición: 
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (numero == 1)
}

Ejercicio 3, e) 

function esFigura_(carta){
    /*
    Propósito: 
    - Indica si el número **numero** corresponde a una figura.
    Parámetros: 
    - carta: Carta / Carta a determinar si es figura.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (numero(carta) == 10 || numero(carta) == 11 || numero(carta) == 12)
}

Ejercicio 3, f) 

function esDeOro_(carta){
    /*
    Propósito: 
    - Indicar si la carta **carta** es del palo oro.
    Parámetros:
    - carta: Carta / Carta a determinar si es del palo "Oro".
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (palo(carta) == Oros)
}

Ejercicio 3, g)

function tieneUnNumeroMasGrande_Que_(primeraCarta, segundaCarta){
    /*
    Propósito: 
    - Indica si el número de la carta **primeraCarta** es más grande que el número de la carta **segundaCarta**.
    Parámetros:
    - primeraCarta: Carta / Primera carta a analizar.
    - segundaCarta: Carta / Segunda carta a analizar.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (numero(primerCarta) > numero(segundaCarta))
}

Ejercicio 3, h)

function sonDelMismoPalo_Y_(primerCarta, segundaCarta){
    /*
    Propósito:
    - Indica si las cartas **primerCarta** y **segundaCarta** son del mismo palo.
    Parámetros:
    - primerCarta: Carta / Primer carta a determinar si es del mismo palo.
    - segundaCarta: Carta / Segunda carta a determinar si es del mismo palo.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (palo(primerCarta) == palo(segundaCarta))
}

Ejercicio 3, i)

function valorParaEnvidoDe_(carta){
    /*
    Propósito: 
    - Indica el número que aporta la carta **carta** para el canto del envido. 
    Parámetros: 
    - carta: Carta / Carta a indicar el valor que aportaría en el envido.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Número.
    Observaciones:
    - Si la carta es una figura, el número que aporta es cero.
    */
    return (choose numero(carta) when (numero(carta) <= 7 && numero(carta) >= 1)
                   0 otherwise)
}

Ejercicio 3, j) NO TERMINADO

function mayorValorEntre_Y_(primeraCarta, segundaCarta){
    /*
    Propósito:
    - Indica el valor más grande entre las cartas **primeraCarta** y **segundaCarta**, según lo que aporta cada una para el envido.
    Parámetros:
    - primeraCarta: Carta.
    - segundaCarta: Carta.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Número. 
    */
    return (choose maximoEntre_Y_(numero(primeraCarta), numero(segundaCarta)) when (numero(PrimeraCarta) <= 7 && numero(segundaCarta) <= 7)
                   numero(primeraCarta) when (numero(primeraCarta) <= 7 && numero(segundaCarta) >= 10)
                   numero(segundaCarta) otherwise)
}

Ejercicio 3, k)

function sumaParaElEnvidoCon_Y_(primeraCarta, segundaCarta){
    /*
    Propósito:
    - Indica el número que tienen las cartas **primeraCarta** y **segundaCarta** para el envido.
    Parámetros:
    - primeraCarta: Carta.
    - segundaCarta: Carta.
    Precondiciones:
    - Las cartas **primeraCarta** y **segundaCarta** deben ser del mismo palo.
    Tipo:
    - Número.
    */
    return (choose numero(primeraCarta) + numero(segundaCarta) + 20 when (numero(PrimeraCarta) <= 7 && numero(segundaCarta) <= 7)
                   numero(primeraCarta) + 20 when (numero(primeraCarta) <= 7 && numero(segundaCarta) >= 10)
                   numero(segundaCarta) + 20 when (numero(segundaCarta) <= 7 && numero(primeraCarta) >= 10)
                   20 otherwise)
}

Ejercicio 3, l)

function sonMejores_Y_Que_Y_(primeraCartaPrimerJugador, segundaCartaPrimerJugador, primeraCartaSegundoJugador, segundaCartaSegundoJugador){
    /*
    Propósito:
    - Indica si las cartas del primer jugador son mejores que las del segundo para el envido.
    Parámetros:
    - primeraCartaPrimerJugador: Carta.
    - segundaCartaPrimerJugador: Carta.
    - primeraCartaSegundoJugador: Carta.
    - segundaCartaSegundoJugador: Carta.
    Precondiciones:
    - El primer y el segundo jugador deben de tener envido.
    Tipo:
    - Booleano.
    */
    return (sumaParaElEnvidoCon_Y_(primeraCartaPrimerJugador, segundaCartaPrimerJugador) > sumaParaElEnvidoCon_Y_(primeraCartaSegundoJugador, segundaCartaSegundoJugador))
}

Ejercicio 4, a) 

function celdaActual(){
    /*
    Propósito:
    - Indica la celda actual.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Celda.
    */
    return (Celda (cantidadDeAzules <- nroBolitas(Azul)
                 , cantidadDeNegras <- nroBolitas(Negro)
                 , cantidadDeRojas <- nroBolitas(Rojo)
                 , cantidadDeVerdes <- nroBolitas(Verde))
}

Ejercicio 4, b)

procedure EscribirEnCelda_(celdaACopiar){
    /*
    Propósito:
    - Escribe la información de la celda **celdaACopiar** en la celda actual.
    Parámetros:
    - celdaACopiar: Celda / Celda a copiar información en la celda actual.
    Precondiciones:
    - Ninguna.
    */
    Poner_DeColor_(cantidadDeAzules(celdaACopiar), Azul)
    Poner_DeColor_(cantidadDeNegras(celdaACopiar), Negro)
    Poner_DeColor_(cantidadDeRojas(celdaACopiar), Rojo)
    Poner_DeColor_(cantidadDeVerdes(celdaACopiar), Verde)
}

Ejercicio 4, c)

function tienenMismaCantidadDeRojas_Y_(primeraCelda, segundaCelda){
    /*
    Propósito:
    - Indica si la celda **primeraCelda** y la celda **segundaCelda** tienen la misma cantidad de bolitas del color rojo.
    Parámetros:
    - primeraCelda: Celda.
    - segundaCelda: Celda.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Booleano.
    */
    return (cantidadDeRojas(primeraCelda) == cantidadDeRojas(segundaCelda))
}

Ejercicio 5, a)

type Persona is record {
    /*
    Propósito:
    - Modelar una persona.
    Inv. Rep.: 
    - Ninguna.
    */
    field dni            //Un valor de tipo string.
    field domicilio      //Un valor de tipo string.
    field esDontante     //Un valor de tipo booleano.
}

Ejercicio 5, b)

function sonConvivientes_Y_(primerPersona, segundaPersona){
    /*
    Propósito: 
    - Indica si dos personas (**primerPersona** y **segundaPersona**) conviven en el mismo domicilio.
    Parámetros:
    - primerPersona: Persona / Primer persona a determinar si vive en el mismo domicilio.
    - segundaPersona: PErsona / Segunda persona a determinar si vive en el mismo domicilio.
    Precondiciones:
    - Las personas **primerPersona** y **segundaPersona** no pueden ser la misma persona.
    Tipo:
    - Booleano.
    */
    return (domicilio(primerPersona) == domicilio(segundaPersona))
}

Ejercicio 5, c)

function personaNacidaDe_(personaMadre){
    /*
    Propósito: 
    - Indica una persona que es hijo/a de la persona **dniMadre**. 
    Parámetros: 
    - personaMadre: Persona / Madre de la persona a que nació.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Persona.
    */
    return (Persona (dni <- sinAsignar()
                    , domicilio <- domicilio(personaMadre)
                    , esDonanteDeOrganos <- False)
}

Ejercicio 5, d)

function persona_RegistradaCon_(personaSinAsignar, dniAAsignar){
    /*
    Propósito: 
    - Indica a la persona **personaSinAsignar** su nuevo número de DNI **dniAAsignar**. 
    Parámetros:
    - personaSinAsignar: Persona / Persona que no tiene dni asignado.
    - dniAAsignar: Número / Número de DNI a asignar.
    Precondiciones: 
    - La persona **personaSinAsignar** no debe tener DNI asignado.
    Tipo: 
    - Persona.
    */
    return (Persona (dni <- dniAAsignar
                    ,domicilio <- domicilio(personaSinAsignar)
                    ,esDonanteDeOrganos <- esDonanteDeOrganos(personaSinAsignar))
}

Ejercicio 5, e)

function persona_ConDomicilioNuevoEn_(personaDelDomicilio, domicilioACambiar){
    /*
    Propósito:
    - Indica a la persona con su nuevo domicilio.
    Parámetros:
    - personaDelDomicilio: Persona / Persona a la cual asignarle el nuevo domicilio.
    - domicilioACambiar: String / Nuevo domicilio a asignar.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Persona.
    */
    return (Persona (personaDelDomicilio | domicilio <- domicilioACambiar))
}

Ejercicio 5, f)

function persona_ConSituacionComoDonanteCambiada(personaACambiarDonar){
    /*
    Propósito: 
    - Indica la persona **personaACambiarDonar** con la situación de donante cambiada.
    Parámetros:
    - personaACambiarDonar: Persona / Persona a cambiar su situación de donación.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Persona.
    */
    return (Persona(personaACambiarDonar | esDonanteDeOrganos <- not esDonanteDeOrganos(personaACambiarDonar))
}

Ejercicio 6) 

type Empleado is record {
    /*
    Propósito: 
    - Modela el perfil del empleado dentro de la empresa.
    Inv. Rep.: 
    - Ninguna.
    */
    field persona //  Un valor del tipo Persona.
    field puesto // Un valor del tipo Puesto.
    field sueldo // Un valor del tipo Número.
}

type Puesto is variant {
    /*
    PROPÓSITO: Modelar los diferentes puestos que hay
    dentro de una empresa de software
    */
    case GestorDeProyecto {}
    case LiderDeProyecto {}
    case Desarrollador {}
    case Operador {}
}

Ejercicio 6, a)

function empleado_ConSueldoActualizadoA_(empleadoACambiarSueldo, nuevoSueldo){
    /*
    Propósito: 
    - Indica el empleado **empleadoACambiarSueldo** con el sueldo actualizado con **nuevoSueldo**. 
    Parámetros:
    - empleadoACambiarSueldo: Empleado / Empleado a actualizar el sueldo.
    - nuevoSueldo: Número / Nuevo sueldo a actualizar.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Empleado.
    */
    return (Empleado(empleadoACambiarSueldo | sueldo <- nuevoSueldo))
}

Ejercicio 6, b) 

function empleado_ConNuevoPuesto_(empleadoACambiar, nuevoPuesto){
    /*
    Propósito:
    - Indica el empleado **empleadoACambiar** con su nuevo puesto **nuevoPuesto**.
    Parámetros: 
    - empleadoACambiar: Empleado / Empleado a cambiar el puesto.
    - nuevoPuesto: Puesto / Nuevo puesto para el empleado.
    Precondiciones:
    - Ninguna.
    Tipo:
    - Empleado.
    */
    return (Empleado(empleadoACambiar | puesto <- nuevoPuesto))
}

Ejercicio 6, c) 

function categoriaDelPuesto_(puesto){
    /*
    Propósito: 
    - Indica la categoría del puesto **puesto**.
    Parámetros: 
    - puesto: Puesto / Puesto a indicar su categoría.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Número.
    */
    return (choose 4 when (puesto == GestorDeProyecto)
                   3 when (puesto == LiderDeProyecto)
                   2 when (puesto == Desarrollador)
                   1 otherwise)
}

Ejercicio 6, d) 

function empleadoConMayorCargoEntre_Y_(primerEmpleado, segundoEmpleado){
    /*
    Propósito: 
    - Indica el empleado con mayor categoría entre dos empleados **primerEmpleado** y **segundoEmpleado**.
    Parámetros: 
    - primerEmpleado: Empleado / Primer empleado a comparar.
    - segundoEmpleado: Empleado / Segundo empleado a comparar.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Empleado.
    */
    return (choose primerEmpleado when (categoriaDelPuesto_(puesto(primerEmpleado)) > categoriaDelPuesto_(puesto(segundoEmpleado))
                   segundoEmpleado otherwise)
}

Ejercicio 6, e)

function tienenIgualSueldo_Y_(primerEmpleado, segundoEmpleado){
    /*
    Propósito: 
    - Indica si los dos empleados **primerEmpleado** y **segundoEmpleado** tienen el mismo sueldo.
    Parámetros: 
    - primerEmpleado: Empleado / Primer empleado a comparar.
    - segundoEmpleado: Empleado / Segundo empleado a comparar.
    Precondiciones: 
    - Ninguna.
    Tipo: 
    - Booleano.
    */
    return (sueldo(primerEmpleado) == sueldo(segundoEmpleado))
}

Ejercicio 6, f) 

function empleado_ConAumentoEn_PorBonoDeFinalizacionDeProyecto(empleado, porcentajeDeAumento){
    /*
    Propósito: 
    - Indica al empleado **empleado** con el sueldo actualizado en base al aumento **porcentajeDeAumento** que le corresponde.
    Parámetros:
    - empleado: Empleado / Empleado que recibe el aumento.
    - porcentajeDeAumento: Número / Porcentaje de aumento para el sueldo del empleado **empleado**.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Empleado.
    */
    return (Empleado(empleado | sueldo <- ((sueldo(empleado) div 100) * porcentajeDeAumento) + sueldo(empleado)))
}

Ejercicio 6, g)

function empleado_ConDomicilioActualizadoA_(empleado, nuevoDomicilio){
    /*
    Propósito: 
    - Indica el empleado **empleado** con su domicilio actualizado con el nuevo domicilio **nuevoDomicilio**.
    Parámetros:
    - empleado: Empleado / Empleado a cambiar el domicilio.
    - nuevoDomicilio: String / Nuevo domicilio del empleado **empleado**.
    Precondiciones:
    - Ninguna.
    Tipo: 
    - Empleado.
    */
    return (Empleado(empleado | identidad <- Persona(identidad(empleado) | domicilio <- domicilioNuevo)
}

POSIBLE:
return (Empleado(empleado | identidad <- Persona(identidad(empleado) | domicilio <- domicilioNuevo)


Ejercicio 7) 





